using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using SFB;

[RequireComponent(typeof(Button))]
public class SaveHEXPalette : MonoBehaviour, IPointerDownHandler
{
    const string MENU_TITLE = "Sava as HEX color conversion";
    private string _data;

    public void Awake()
    {
        useGUILayout = false;
    }

#if UNITY_WEBGL && !UNITY_EDITOR
    //
    // WebGL
    //
    [DllImport("__Internal")]
    private static extern void DownloadFile(string gameObjectName, string methodName, string filename, byte[] byteArray, int byteArraySize);

    // Broser plugin should be called in OnPointerDown.
    public void OnPointerDown(PointerEventData eventData)
    {
        if (ImageUtilities.input_palette.Count == 0) return;
        SaveFile();
        var bytes = Encoding.UTF8.GetBytes(_data);
        DownloadFile(gameObject.name, "OnFileDownload", ImageUtilities.filename + ".txt", bytes, bytes.Length);
    }

    // Called from browser
    public void OnFileDownload()
    {
        //output.text = "File Successfully Downloaded";
    }
#else
    //
    // Standalone platforms & editor
    //
    public void OnPointerDown(PointerEventData eventData) { }

    // Listen OnClick event in standlone builds
    void Start()
    {
        (GetComponent<Button>()).onClick.AddListener(OnClick);
    }

    public void OnClick()
    {
        if (ImageUtilities.input_palette.Count == 0) return;

        var path = StandaloneFileBrowser.SaveFilePanel(MENU_TITLE, "", ImageUtilities.filename, "txt");

        if (!string.IsNullOrEmpty(path))
        {
            SaveFile();
            File.WriteAllText(path, _data);
        }
    }
#endif

    public void SaveFile()
    {
        // ensure we have something to export
        if (ImageUtilities.input_palette.Count == 0) return;

        StringBuilder sb = new StringBuilder("// This file generated by Color Palette Swapper\r\n// https://williamthompsonj.github.io/Color-Palette-Swapper/\r\n", 1000);

        int i, j;
        bool toggle;
        ColorPlus output_color;
        List<Color32> done_colors = new List<Color32>();
        List<ColorPlus> input_list = new List<ColorPlus>();
        List<ColorPlus> transparent = new List<ColorPlus>();

        // remove transparent colors from main list (tac onto end of input list)
        for (i = 0; i != ImageUtilities.input_palette.Count; i++)
        {
            if (ImageUtilities.input_palette[i].alpha >= ImageUtilities.transparent_threshhold)
                input_list.Add(ImageUtilities.input_palette[i]);
            else
                transparent.Add(ImageUtilities.input_palette[i]);
        }

        // cycle though input colors
        if (ImageUtilities.output_palette.Count == 0)
        {
            // no output, dump input hex colors
            for (i = 0; i != input_list.Count; i++)
            {
                sb.AppendFormat("\r\n{0}", input_list[i].hex);
            }
        }
        else
        {
            // map input to output colors
            for (i = 0; i != input_list.Count; i++)
            {
                sb.AppendFormat("\r\n{0}", input_list[i].hex_match);
                done_colors.Add(input_list[i].match);
            }
        }

        // add colors from output palette that aren't mapped
        for (i = 0; i != ImageUtilities.output_palette.Count; i++)
        {
            // shorthand reference to current output color
            output_color = ImageUtilities.output_palette[i];

            // dump transparent output colors
            if (output_color.alpha < ImageUtilities.transparent_threshhold) continue;

            // determines if this output color has already been listed
            toggle = false;

            // compare output colors with input colors
            for (j = 0; j != done_colors.Count; j++)
            {
                // check if output color matches an existing color
                if (output_color.Equals(done_colors[j]))
                {
                    toggle = true;
                    break;
                }
            }

            if (!toggle)
            {
                sb.AppendFormat("\r\n{0}", output_color.hex);
                done_colors.Add(output_color.match);
            }
        }

        // create string builder
        sb.Append("\r\n\r\n// This is how you map transparent colors");

        if (transparent.Count == 0)
        {
            // show curious users how to map transparent colors
            sb.Append("\r\n#c0ffee00 -> #c00c0000");
        }
        else
        {
            // use existing transparent colors as examples
            for(i = 0; i != transparent.Count; i++)
            {
                sb.AppendFormat("\r\n{0} -> #ffffff00", transparent[i].hex);
            }
        }

        _data = sb.ToString();
    }
}